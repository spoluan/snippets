### **Canonical Constructor in Java Records**

The **canonical constructor** in Java Records is a constructor whose parameters exactly match the properties (fields) declared in the record's header. This constructor is automatically generated by the compiler, and it initializes all the properties of the record. However, developers have the option to explicitly define the canonical constructor if additional logic (e.g., validation, transformation) is needed during object creation.

---

### **Key Points about Canonical Constructor**

1. **Automatically Generated**:
   - By default, every record has a canonical constructor automatically generated by the compiler.
   - This constructor initializes all the fields of the record.

2. **Explicit Definition**:
   - Developers can explicitly define the canonical constructor if they need to add custom logic (e.g., validation, data transformation).
   - When explicitly defining the canonical constructor, all fields must be initialized because fields in records are `final`.

3. **Mandatory Initialization**:
   - In the canonical constructor, you must initialize all the fields of the record, as they are implicitly `final`.

4. **Called Automatically**:
   - The canonical constructor is automatically called when creating an object of the record.

---

### **Examples of Canonical Constructor**

#### **1. Default Canonical Constructor (Implicit)**

If no explicit constructor is defined, the compiler generates the canonical constructor automatically.

```java
public record Customer(String id, String name, String email, String phone) { }

public class Main {
    public static void main(String[] args) {
        // Using the default canonical constructor
        Customer customer = new Customer("1", "Sevendi", "Sevendi@localhost", "088888");
        System.out.println(customer);
    }
}
```

**Output:**
```
Customer[id=1, name=Sevendi, email=Sevendi@localhost, phone=088888]
```

---

#### **2. Explicit Canonical Constructor**

You can explicitly define the canonical constructor to add custom logic.

```java
public record Customer(String id, String name, String email, String phone) {
    public Customer(String id, String name, String email, String phone) {
        System.out.println("Creating Customer...");
        this.id = id.toLowerCase(); // Convert ID to lowercase
        this.name = name;
        this.email = email != null ? email.toLowerCase() : null; // Normalize email
        this.phone = phone;
    }
}
```

Usage:

```java
public class Main {
    public static void main(String[] args) {
        Customer customer = new Customer("1", "Sevendi", "Sevendi@LOCALHOST", "088888");
        System.out.println(customer);
    }
}
```

**Output:**
```
Creating Customer...
Customer[id=1, name=Sevendi, email=Sevendi@localhost, phone=088888]
```

---

#### **3. Validation in Canonical Constructor**

You can use the canonical constructor to validate inputs before initializing the fields.

```java
public record Customer(String id, String name, String email, String phone) {
    public Customer(String id, String name, String email, String phone) {
        if (id == null || id.isBlank()) {
            throw new IllegalArgumentException("ID cannot be null or blank");
        }
        if (email != null && !email.contains("@")) {
            throw new IllegalArgumentException("Invalid email address");
        }
        this.id = id;
        this.name = name;
        this.email = email;
        this.phone = phone;
    }
}
```

Usage:

```java
public class Main {
    public static void main(String[] args) {
        try {
            Customer customer = new Customer("", "Sevendi", "invalid_email", "088888");
        } catch (IllegalArgumentException e) {
            System.out.println(e.getMessage());
        }
    }
}
```

**Output:**
```
ID cannot be null or blank
```

---

#### **4. Transformation in Canonical Constructor**

You can use the canonical constructor to transform the input data before storing it in the fields.

```java
public record Product(String id, String name, double price) {
    public Product(String id, String name, double price) {
        this.id = id.trim(); // Remove leading/trailing spaces
        this.name = name.toUpperCase(); // Convert name to uppercase
        this.price = Math.max(price, 0); // Ensure price is non-negative
    }
}
```

Usage:

```java
public class Main {
    public static void main(String[] args) {
        Product product = new Product(" 123 ", "laptop", -500);
        System.out.println(product);
    }
}
```

**Output:**
```
Product[id=123, name=LAPTOP, price=0.0]
```

---

#### **5. Using Annotations in Canonical Constructor**

You can add annotations to the parameters of the canonical constructor for validation or documentation purposes.

```java
import javax.validation.constraints.NotNull;

public record Customer(@NotNull String id, String name, String email, String phone) {
    public Customer {
        if (id == null) {
            throw new IllegalArgumentException("ID must not be null");
        }
    }
}
```

Usage:

```java
public class Main {
    public static void main(String[] args) {
        try {
            Customer customer = new Customer(null, "Sevendi", "Sevendi@localhost", "088888");
        } catch (IllegalArgumentException e) {
            System.out.println(e.getMessage());
        }
    }
}
```

**Output:**
```
ID must not be null
```

---

#### **6. Testing Canonical Constructor**

You can write unit tests to verify the behavior of the canonical constructor.

```java
import static org.junit.jupiter.api.Assertions.*;

public class CustomerTest {
    @Test
    void testCanonicalConstructor() {
        Customer customer = new Customer("1", "Sevendi", "Sevendi@LOCALHOST", "088888");

        assertEquals("1", customer.id());
        assertEquals("Sevendi", customer.name());
        assertEquals("Sevendi@localhost", customer.email()); // Normalized email
        assertEquals("088888", customer.phone());
    }

    @Test
    void testValidationInCanonicalConstructor() {
        Exception exception = assertThrows(IllegalArgumentException.class, () -> {
            new Customer(null, "Sevendi", "Sevendi@localhost", "088888");
        });
        assertEquals("ID must not be null", exception.getMessage());
    }
}
```

---

### **Summary**

1. **What is a Canonical Constructor?**
   - A constructor in a record whose parameters exactly match the fields in the record header.
   - Automatically generated by the compiler but can be explicitly defined for additional logic.

2. **Why Use Canonical Constructor?**
   - To add validation, transformation, or logging during object creation.
   - To ensure all fields are properly initialized.

3. **Key Characteristics:**
   - All fields in the record must be initialized because they are `final`.
   - It is automatically called when creating an object.

4. **Examples of Use Cases:**
   - Validation of inputs.
   - Transformation of inputs (e.g., normalizing strings, ensuring non-negative values).
   - Adding annotations for validation frameworks.
